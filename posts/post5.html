<!DOCTYPE html>
<div class="container post" >
  <h3>Post 5: 2/19/2018</h3>
    <p>At the beginning of the week, our UI/UX guy, Ian, began to integrate the statistics service into our own Darklight environment for testing and usability. In the process he found some good gotchia’s and brought up an inconsistency issue with another service that is used in our framework.</p>
    <p>The first thing that Ian had trouble with was adding data to the sample data bins. The chain that he added the statistics step to was not failing or throwing errors as the chain was triggered by events. Because of this, it was assumed that the service was gathering data until it was at the minimum size described in the step configuration but rather, the desired data from the chain package was not being properly referenced due to the implied formatting of the test variable field. This implication was not understood so no value was extracted.</p>
    <p>Freemarker is a common api we use for users to identify variables in the chain packages. Say for instance a step saves a variable with the name loginName. Another step down the chain needs this variable. If the field that is to reference this variable uses freemarker, it is possible that the expression could be ${loginName[0]} or ${loginName[0][0]}, depending on how the variable was saved in code. This will be expanded on later. Now if the field does not use freemarker, then no expression is needed and only the name of the variable. Ian saved the variable he wanted to be used in the statistics step in an array that needed to be accessed via freemarker, something like ${regexIpRes[1]}. Because the field did not read freemarker, it looked for a variable with the name that is the raw expression, which returned nothing. </p>
    <p>When designing the service, I added some command line options for developers and advanced users to get some information about that sample data. One of these commands was to view the database holding the information as the key of the sample set with the number of records. Ian used this command to see if data was actually being added to the sample set and this is when he discovered the error in the implication. After some paired investigation we determined that the field needed to be extended so that it reads freemarker. What makes this more convenient is that it still works with the intended referencing of the variables in the package. Using the example above, the expression ${loginName} is the same as the variable name, loginName.</p>
    <p>Now, with freemarker introduced here, it leads the second problem of referencing variables. Currently, the only true way to know how a variable is saved and should be referenced with freemarker, is to use Darklight’s inventory view to see see values in a chain package. The variable names of the package a shown as they would in freemarker: foobar, foobar[*], and foobar[*][*]. As stated before, the way these variables are shown depend on how they are stored in code.</p>
    <p>While we do not want to provide more headache for users, we need to determine a consistent methodology for storing variables. We provide documentation on freemarker and how it is used in Darklight but we do not have anything that explains the storing of variables depending on the step they are being stored from. I and developer that implemented freemarker into Darklight, Peter, have been tasked with normalizing this paradigm. That will be part of this upcoming weeks tasks along with attempting to finish the refactoring of the refier configuration view.</p>
</div>