<!DOCTYPE HTML>
<div class="container post">
  <h3>Post 2: 1/24/2018</h3>
  <p>This past week has been focused on the extension of the statistics service developed the previous weeks. The core framework for the service was finished, leading to the next portion of the project being the step user interface. This task was considerably different than the previous step editors I had implemented before because of the extensive logic in the configuration and multiple data specifications that can be used to gather sample data from the repository.</p>
  <p>Once the user interface was initially designed using Balsamiq, the next couple days were spent getting the code written up and the logic implemented as best I could. My methodology follows that I first get the UI elements into the view in the order and layout that was designed. Once everything is where it needs to be and is arranged accordingly, I place in the element listeners. In Java, listeners (in UI) are interfaceâ€™s that listen to events triggered for by different interactions on that element. Most of the types of listeners used in this case were modification adapters for text fields and selection adapters for buttons and combo boxes.</p>
  <p>Verification of text fields was also needed to ensure that values saved to the configuration are valid for the service to work properly when called upon. Whatever is saved on the client front end is used by the server backend to run a service before the result being serialized back across the network the client to display.</p>
  <p>While constructing the user interface was a slight challenge, the need for a statistics repository garbage collection mechanism was needed to maintain stale or unreferenced data. Because the amount of storage that can occur with this service, it is crucial that a method be in place to account for scalability. This became far more difficult to tackle since the addition of freemarker capability with reference keys.</p>
  <p>The difficulty with freemarker is that any number of generated values from the freemarker expression can occur, possibly. For instance, suppose that AT&T is using Darklight in their enterprise. As once can imagine, there could be thousands or tens of thousands of computer devices hooked up to the network. If they want to run logon analytics for each device, one freemarker expression can possibly be used for one playbook. Another added difficulty is that any other playbook using the statistics step can use the same expression. So now the variability is doubled for garbage collection because now there is one to many to many reference (one expression with many generated values for many possible step references).</p>
</div>