<!DOCTYPE html>
<div class="container post" >
  <h3>Post 6: 3/3/2018</h3>
  <p>The past couple weeks have not seen much change in the projects that I have been assigned with. The statistics service has been undergoing testing in our local development network, which is being done by Ian Robertâ€™s, our user interface and user interaction expert. While testing the service, he did find some bugs that have been noted for me to fix. He expressed a lot of anxious waiting to me as he awaits to opportunity to really use the service.</p>
  <p>The reifier view refactor has been going slow. What I am really beginning to understand is taking over another programmers feature code is a daunting task of learning the others coding style and initial thought process. Taking this code and expanding the feature functionality across multiple packages and 20+ classes and creating new ones to accommodate missing pieces. Much of the time taken so far has been making mistakes and learning actual functionality versus perceived.</p>
  <p>Last week my supervisor asked how long it might take for me to finish this refactor because there is much need for upcoming proof of concepts. I had initially told him that it would be two weeks but that was a loose estimate since I am a full time student first and the time I would need to take for school would obviously hinder progress. My new estimate is that it might take an extra week, the 16th of March.</p>
  <p>Currently, I am adding UI functionality to all the dialogs that allow the selection of array indexes if the JSON path of the selected element for the configuration. Before doing this, I had previously attempted to render and save path labels that would result from the indexing but I soon came to realize that without the new user interface, I would not be able to properly determine the algorithm needed to support all the possible element indexing, whether they be literal arrays, object arrays, arrays of arrays, or nested combinations. Either way, the full set of indexes would be needed for writing the configuration correctly as a result.</p>0
  <p>Last week, I gave short and rather incomplete demonstration of the refactor at the request of my superiors. When this was requested, I wrote a few sample JSON sets that would show the possible JSON combinations; literals, arrays, objects, array of literals, array of objects, etc, all the way to third level paths. What I discovered from this, and was not known to the previous developer, was that not all the possible combinations were rendered and mapped correctly in the sample portion of the view. So even though the raw JSON was shown correctly outside the application, once run through the parsing algorithm of our software for this view, the algorithm was not correctly hitting all the possible valid conditions that JSON actually supports.</p>
  <p>The question now is, even though the JSON specification allows for such nonsense of structure, is it necessary for Darklight to handle it? If so, this very well may put a stop to the progress I am making now and divert my attention to this issue because I would not know how it will affect the algorithms I am placing now. However, if we decide not to, the JSON structures that we do support will need to be documented and visible to those who may have data that is ridiculously structured. I do not see this being a problem because so far we have not come across any issues with the parsing of any JSON structures that have come from logging appliances; splunk, logstash, kabana, osquery, etc. I will reflect more on this early this upcoming week, along with some thoughts about switching out databases for our metadata service and statistics service.</p>
</div>