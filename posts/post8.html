<!DOCTYPE html>
<div class="container post" >
  <h3>Post 8: 3/31/2018</h3>
  <p>At the start of last week I was able to finish up the features needed to submit a merge request for the refier refactor that has essentially been my life at work for the last 6 weeks. When I was ready for this to happen, I asked my superiors on what the process might be for the merge to happen considering this was a large code change that was essential to not being broken when merged. Since I was constantly having to test while I progressed, they did not see the merge being a issue so long as the previous version of reifiers were not broken by the new changes. So with that said, the code was merged rather quickly (a couple days, if that), and is currently going through routine use.</p>
  <p>Along the way there has been no problems with those who have been using the system but fortunately I was able to discover a couple bugs when rendering older configurations paths. These were quickly addressed and changes were made and merged in with the code before anyone else was came across it.</p>
  <p>Not long after that, another task related to the reifier was brought to my attention but was more of an extension. One of the neat features of these configurations is that there is an option to add match pattern rules that are used to distinguish incoming JSON data to their needed reifier because it is possible that a type of log that we read may required different reifiers based on the contents of the incoming JSON.</p>
  <p>The original match patterns allowed you match a JSON path, ignoring what the value of the field is, or a JSON path with a matching value. If the incoming JSON matches these sets of rules, then the system knows to use that reifier configuration to reify the data. The is very useful and adds to our AI patterns used in Darlight by allowing it figure out for itself what it needs to do with data and how to handle it without the explicit handling of the user.</p>
  <p>The extensions asked for expanded these match pattern options to check for the value of the JSON path to either contain, start with, end with, or match a regular expression. These are helpful for values that are prefixed with some specific meaning that gives some context to the data. The code required for this was simple and a one dayer in order to get done. Simple, elegant, and very helpful.</p>
  <p>Ian, our UX/UI guy, came to me with a frustration of his with how our system displays some error messages to the users when a step in the chain fails due to an exception occuring during processing. The processing portion of that step he was working on did not have very good or robust error handling, where the try/catch block encapsulated most of the code and outputed the message of the thrown exception, which in this case was simply <strong>null</strong>. I was able to easily fix this error but it brought to light a deeper issue that needed to be addressed.</p>
  <p>Our step editors for the playbook were created by myself and another developer, who at the time of starting to write most of these editors, was still learning the concepts of programming. As she made new steps, her understanding and implementation patterns she began to develop changed, therefore almost each step editor was its own one way or another. Whether the margins were slightly different, or the way validation was handled (if at all) was not consistent throughout the library.</p>
  <p>Much of the major implementation of Darklight has been set and not very many major new features are being brought in any time soon. With that in mind, I had brought up the idea of normalizing this library of code so that the issues described earlier can be addressed so all step editors render and function the same way as they should. My intention is that, when all this is done, to turn the step editor pattern into an API so that the rules of the code can be better enforced for future steps.</p>
  <p>However, I was later informed by our core user interface developer that much of the code he is refactoring for our ontology management, may possibly conflict with changes that I would be making. So what I am doing now is attempting to discover and document patterns that I see throughout the editors code and to identify where some missing features are in what editors.</p>
</div>